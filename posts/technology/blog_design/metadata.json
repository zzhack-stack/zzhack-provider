{
  "cover": "https://img-blog.csdnimg.cn/521dd9cc58144e1a94f3de8fef9cc872.jpg",
  "title": "博客设计",
  "filename": "blog_design.md",
  "summary": "如果你想搭建一个自己的博客站点，或者你想有一个地方来放置你无处安放的文章，那么希望这篇文章能够帮到你。我将从头到尾的介绍该博客的搭建过程和架构设计，以及相应的技术栈以及我选型的原因和他们之间可能有的一些生产中细微的差别，你可以将本文当作一篇技术文章看或者非技术文章看都没有关系，只关注你喜欢的部分就好。距离 `zzhack` 上线已经有一段时间了，这篇文章是我在 `zzhack` 上写的第一",
  "content": "如果你想搭建一个自己的博客站点，或者你想有一个地方来放置你无处安放的文章，那么希望这篇文章能够帮到你。\n\n我将从头到尾的介绍该博客的搭建过程和架构设计，以及相应的技术栈以及我选型的原因和他们之间可能有的一些生产中细微的差别，你可以将本文当作一篇技术文章看或者非技术文章看都没有关系，只关注你喜欢的部分就好。\n\n距离 `zzhack` 上线已经有一段时间了，这篇文章是我在 `zzhack` 上写的第一篇正式的文章，我在写这篇 “创世文章” 的时候在想究竟要写一篇什么文章来作为 `zzhack` 的开头呢，想来想去还是从设计讲起吧， 毕竟这也是整个博客站点的骨架。\n\n## Genesis\n在 `zzhack` 之前，我曾在 [小辣抓的博客](https://blog.csdn.net/HaoDaWang) 写了长达四年的博客，但是种种原因我开始有想法自己搭建一个博客平台，`zzhack` 是基于 GitHub Issues 搭建起的博客，这个后面会提到，除此之外现在大概有这么几种方式可以快速帮你构建起一个 blog；\n\n### 0x01 使用 Hexo 之类的框架\n你可能已经注意到现在有很多博客都是用 [Hexo](https://github.com/hexojs/hexo) 这类的工具自动生成的，这类工具可以帮助你快速编译生成一个静态网页，它跟一些文档生成工具是同一类工具，本质上也是一样的，不过它含有一些提升用户体验的 feature 来使生成后的网站更符合 `博客` 类型，比如它可以定制主题甚至你也可以自己制作一套符合自己的主题。\n\n### 0x02 使用 GitHub Issues 作为博客\nGitHub Issues 本身是作为一个问题反馈的工具，但是由于它提供了很多强大功能，比如 Label，版本控制等功能可以帮助你快速整理或归档文章，它基本可以满足一个博客正常的需求，甚至它还自带 markdown 渲染器，是不是感觉 Issues 系统天生就适合作为一个博客平台？所以现在也会有很多人直接使用 GitHub Issues 来作为博客。\n\n### 0x03 自建博客 & GitHub Issues\n虽然 GitHub Issues 的用来做管理分类归档很强大，但是它的可玩性并不高，你不能去 hack 任何一个地方，到底你还是附属在一个其他的平台上写文章，有没有可能既有 GitHub Issues 的体验又有很高的可玩性呢？`zzhack` 就是这样设计的，`zzhack` 是从头到尾自建的博客，但是又想用 GitHub Issues 现有功能，于是想着把 GitHub Issues 作为一个资源提供服务，而实际渲染的客户端由自己的想法来驱动创建，这样的话就能解决这个痛点了！看起来它还是一个典型的 `C/S` 架构，这类的架构的优点就是我可以不用关心任何一端的横向拓展，将来用同一个服务（GitHub Issues）来支撑拓展多端（小程序，App etc.）都是没有问题的。\n\n![zzhack 架构](https://img-blog.csdnimg.cn/217f50b09883437bacc98757cbd6488d.jpg)\n\n基于这种架构搭建的博客还有一个优势是可以把你的博客变的 “热” 起来，从此你的博客不再是静态的页面了，你随时可以在 GitHub Issues 上编辑你的文章，然后发布，而客户端也会随之更新，并且 GitHub 还带有 Markdown 编辑器，还有什么理由说不呢？XD\n\n## 如何做文章管理\nGitHub Issues 有一个非常强大的功能 `Labels`，你可以随时为你的 Issue 打上 Label 以标识一些额外的信息，比如这个 Issue 属于哪一类等。\n\n![Labels](https://img-blog.csdnimg.cn/23646509024541b79f06582f6894e8a0.png)\n\n它的强大之处就在于可以在 `Issue` 上添加一些额外的信息，这些信息就类似于 `元数据`，你可以用这些数据来描述你想展示的数据。比如我想将一些现有的文章进行分类，我可以设置一些 `Label` 来标识它们到底属于哪一类。\n\n```\nfilter:technology\n```\n\n将这个 Label 打到你想要分类到 `technology` 的文章上就简单的实现了分类，接下来只需要在客户端实现一个针对于 Labels 的解析器，整个分类系统就完成了。当然这只是 Label 的一部分实际运用，而它的本质其实就是给文章添加元数据，因此，它还有无限的可能性，这都依赖于你如何去解析 Label。\n\n合理的运用 Label 来给 Issue 添加元信息就可以完成我们所需要的大部分功能了。\n\n> Notice：为了方便数据和实际的 Issue 作用分离，我将数据提供相关的代码和 Issues 单独放在了一个仓库 [youncccat/blog-database](https://github.com/youncccat/blog-database)，对于 `zzhack` 的所有文章你都能在这里找到。\n\n除此之外，使用 Issue 来做资源提供服务还有一个好处，你可以允许其他人来在你的平台上提供文章，理论上贡献者只需要新开一个 Issue 就是一篇新的文章了，如果你要做访问控制，也可以通过 Label 来决定哪些是正式文章（可以直接渲染的），哪些是审核中的文章。 \n\n## 技术选型\n为了快速的计算和渲染，决定使用 WebAssembly（后称 wasm） 来作为基本的技术选型，我从 18 年开始持续关注这个（wasm）技术，但由于当时生态受限，并没有一些出色的 wasm 框架（UI）崭露头角，直到现在已经有大批的 wasm 的 lib 开始涌现，但始 wasm 的 web 产品却是少之又少，局限于 wasm 并不能操作 DOM，所以我需要的不仅仅是 wasm，而是需要把 wasm 和 JS 整合在一起的一整套工具链，当前的 wasm 生态中，Rust 的 [Yew](https://github.com/yewstack/yew) 是不错的选择（请注意，目前 Yew 还未发布正式版），它是一个 Rust 的 UI 框架，搭配 [Trunk](https://github.com/thedodd/trunk) 和可以将 Rust 编译成 wasm + js 的 bundle，在开发和生产下的体验都是极好的。\n\n```github\n{\n    \"url\": \"https://github.com/youncccat/zzhack\",\n    \"repo\": \"zzhack\",\n    \"description\": \"My personal blog site\"\n}\n```\n\n基本的技术选型为：\n- UI Framework: [Yew](https://github.com/yewstack/yew)\n- Language: [Rust](https://www.rust-lang.org/)\n- Router: [yew_router](https://github.com/yewstack/yew_router)\n- Bundle util: [Trunk](https://github.com/thedodd/trunk) \n- JS DOM: [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys)\n\n关于其余用到的工具可以参考 zzhack 的 [Cargo.toml](https://github.com/youncccat/zzhack/blob/main/Cargo.toml)\n\n```toml\n[package]\nname = \"zzhack\"\nversion = \"0.1.0\"\nauthors = [\"youncccat <mist@zzhack.fun>\"]\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]\nwasm-opt = false\n\n[dependencies]\nyew = \"0.18.0\"\nwasm-bindgen = \"0.2.67\"\nmaterial-yew = { git = \"https://github.com/hamza1311/material-yew\", features = [\"full\"] }\nyew-router = \"0.15.0\"\nstdweb = \"0.4.20\"\ncss-in-rust = \"0.5.0\"\nweb-sys = { version = \"0.3\", features = [\"HtmlMetaElement\", \"Document\", \"Element\", \"DocumentFragment\", \"HtmlTemplateElement\", \"MediaQueryList\"] }\npulldown-cmark = \"0.8.0\"\nonce_cell = \"1.8.0\"\nanyhow = \"1.0.41\"\nserde = \"1.0.126\"\nyewdux = \"0.6.2\"\nregex = \"1.5.4\"\nserde_json = \"1.0.64\"\nchrono = \"0.4.19\"\n\n[dependencies.syntect]\nversion = \"4.5\"\ndefault-features = false\nfeatures = [\n    \"html\",\n    \"dump-load\",\n    \"regex-fancy\"\n]\n\n[build-dependencies]\nsyntect = { version = \"4.5\", default-features = false, features = [\"default-fancy\"] }\n```\n\n## 体验\n使用 Rust 做 Web 开发，不管是前端还是后端，最直观的感受就是它 “不太适合做 Web”，说的不太适合并不是它本身语言的设计 \"缺陷\"，而是 Rust 设计的太过于精致和严谨，而 Web 领域恰恰又不是那么严谨和精致的领域，在用 Rust 做 Web 开发时总感觉有一个东西将自己给束缚住了，它不是动态和静态语言的区别，而是语言本身给 Web 开发者带来的直观感受：“麻烦”。\n\n得益于 Rust 的 [Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)，让 Rust 可以不手动释放内存也不使用 GC 却带来比 GC 管理内存更高的收益，这当然是非常好的设计，可问题就在于 Web 并不需要这么好的设计，我不想每次赋值的时候还去考虑分配 ownership 来达到高效的内存使用，也不想每次实现逻辑的时候还要在乎 ownership 是否转移，毕竟在 Web 领域做内存控制显得有点 “多此一举”，也正是因为这些感受，使得 Rust 对 Web 开发者的体验并不是很友好，相反的，如果 Rust 去替代 C/C++ 做一些底层模块的编写那一定会感受到舒适，并且在舒适的同时也不会带来性能的丢失 🦀️。\n\n### 强大的 Macro\nRust 从发布以来不断完善的 `macro` 也是 Rust 的一大亮点，这种能力可以让你轻松的实现一些你想要的 DSL，Yew 也内置了 html 的 macro，它的工作很简单，就是把 html labels 解析成 virtual DOM，它看起来是这样的：\n\n**[zzhack/src/components/home/header.rs#L180](https://github.com/youncccat/zzhack/blob/main/src/components/home/header.rs#L180)**\n\n```rust\nhtml! {\n            <div class=self.style.clone().to_string()>\n                <div class=\"left\">\n                    {by_reactive(html! {<div onclick=&self.props.on_menu_click style=format!(\"color: {}\", by_theme(\"black\", \"white\"\n                        ))>\n                        <MatIconButton icon=\"menu\" />\n                    </div>}, html!{})}\n                    <div class=\"title\">\n                        {\"ZZHack\"}\n                    </div>\n                    {by_reactive(html!{}, html!{<div class=\"tab_style\">\n                        <MatTabBar active_index=self.current_tab_index onactivated=self.link.callback(|i: usize| HeaderMessage::ChangeRoute(i))>\n                            {for self.props.tabs.iter().map(|tab| html!{\n                            <MatTab label=tab.name is_fading_indicator=true />\n                            })}\n                        </MatTabBar>\n                    </div>})}\n                </div>\n                <div class=\"right\">\n                    <div onclick=self.link.callback(|_| HeaderMessage::SwitchTheme)>\n                        <MatIconButton>\n                            <img src=by_theme(\"/images/dark_mode.svg\", \"/images/light_mode.svg\" ) />\n                        </MatIconButton>\n                    </div>\n                    <a href=GITHUB_PROFILE>\n                        <MatIconButton>\n                            <img src=by_theme(\"/images/github_dark.svg\", \"/images/github_light.svg\" ) />\n                        </MatIconButton>\n                    </a>\n                </div>\n            </div>\n```\n这是非常强大的能力，对我来说，如果你想实现一个 UI 框架，有一个 (whatever)SX 解析器就够了 XD。\n\n## Troubleshooting\n如果你也有想法用 Rust 和 Yew 来构建一个你自己的 web 应用，这里的一些踩坑经验希望能帮到你。\n\n#### 如何在组件之间实现状态共享\n笔者在写这篇文章的时间是 2021/8/1，这个时候 Yew 才 release 了 0.18 的版本，在这个版本中 Yew 并没有支持类似 Context 的东西（在 0.19 中会包含 Context 的 feature），因此你想要在组件之间实现状态共享会稍微麻烦一点，你需要实现一个 Agent（这是一个非常有趣的东西，有空我会专门写一篇 Agent 的文章 XD），然后让各个组件去连接这个 Agent 来实现状态共享。\n\n#### Fetch 的生命周期\n如果你发现你想使用 FetchService 来发送请求，但是却又发不出去，请检查你的 FetchTask 是否持有 ownership，没有 ownership 的成员会被 Rust 在活动范围以外的 scope 释放掉，由此请求发送就会被 cancel，或者直接 abort。\n\n\n\n",
  "create_at": 1635578609086,
  "issue_id": 13
}